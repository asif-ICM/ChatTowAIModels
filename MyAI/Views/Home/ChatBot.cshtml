@{
    ViewData["Title"] = "ChatBot Streaming";
}

<div class="container mt-4">
    <div class="row">
        <div class="col-md-8 offset-md-2">
            <div class="card">
                <div class="card-header">
                    <h3>AI ChatBot with Live Streaming</h3>
                </div>
                <div class="card-body">
                    <div id="chatContainer" class="chat-container" style="height: 400px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; margin-bottom: 15px;">
                        <div class="message bot-message">
                            <strong>AI:</strong> Hello! I'm your AI assistant. Ask me anything and I'll respond with live streaming!
                        </div>
                    </div>
                    
                    <div class="input-group">
                        <input type="text" id="messageInput" class="form-control" placeholder="Type your message..." autocomplete="off">
                        <button id="sendButton" class="btn btn-primary">Send</button>
                        <button id="streamButton" class="btn btn-success">Stream Response</button>
                        <button id="thinkButton" class="btn btn-warning">Think & Respond</button>
                    </div>
                    
                    <div class="mt-3">
                        <small class="text-muted">
                            <strong>Regular Chat:</strong> Send button for normal response<br>
                            <strong>Stream Response:</strong> Stream button for live streaming response<br>
                            <strong>Think & Respond:</strong> Shows thinking process like Cursor AI
                        </small>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<style>
    .message {
        margin-bottom: 15px;
        padding: 12px 16px;
        border-radius: 12px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        transition: all 0.3s ease;
    }
    
    .user-message {
        background: linear-gradient(135deg, #007bff, #0056b3);
        color: white;
        margin-left: 20%;
        border-bottom-right-radius: 4px;
    }
    
    .bot-message {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        color: #333;
        margin-right: 20%;
        border-bottom-left-radius: 4px;
    }
    
    .streaming {
        border-left: 4px solid #28a745;
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2);
        animation: pulse 2s infinite;
    }
    
    .message-header {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 8px;
        font-size: 0.9em;
    }
    
    .timestamp {
        color: #6c757d;
        font-size: 0.8em;
    }
    
    .typing-indicator {
        color: #28a745;
        animation: blink 1s infinite;
        font-size: 1.2em;
    }
    
    .message-content {
        line-height: 1.5;
        word-wrap: break-word;
        white-space: pre-wrap;
    }
    
    .streaming .message-content {
        border-right: 2px solid #28a745;
        animation: typewriter 1s infinite;
    }
    
    @@keyframes pulse {
        0% { box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2); }
        50% { box-shadow: 0 6px 12px rgba(40, 167, 69, 0.4); }
        100% { box-shadow: 0 4px 8px rgba(40, 167, 69, 0.2); }
    }
    
    @@keyframes blink {
        0%, 50% { opacity: 1; }
        51%, 100% { opacity: 0.3; }
    }
    
    @@keyframes typewriter {
        0% { border-right-color: transparent; }
        50% { border-right-color: #28a745; }
        100% { border-right-color: transparent; }
    }
    
    .spinner-border-sm {
        width: 1rem;
        height: 1rem;
    }
    
    .chat-container {
        background: linear-gradient(135deg, #f8f9fa, #e9ecef);
        border-radius: 12px;
        padding: 20px;
    }
    
    .input-group .btn {
        border-radius: 8px;
        font-weight: 500;
    }
    
    .input-group .form-control {
        border-radius: 8px;
        border: 2px solid #e9ecef;
        transition: border-color 0.3s ease;
    }
    
    .input-group .form-control:focus {
        border-color: #007bff;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
    }
    
    /* Thinking message types */
    .message.thinking {
        background: linear-gradient(135deg, #fff3cd, #ffeaa7);
        border-left: 4px solid #ffc107;
        animation: thinking-pulse 2s infinite;
    }
    
    .message.analyzing {
        background: linear-gradient(135deg, #d1ecf1, #bee5eb);
        border-left: 4px solid #17a2b8;
        animation: analyzing-pulse 1.5s infinite;
    }
    
    .message.todo {
        background: linear-gradient(135deg, #f8d7da, #f5c6cb);
        border-left: 4px solid #dc3545;
        animation: todo-pulse 1s infinite;
    }
    
    .message.response-start {
        background: linear-gradient(135deg, #d4edda, #c3e6cb);
        border-left: 4px solid #28a745;
    }
    
    .message.complete {
        background: linear-gradient(135deg, #d1ecf1, #bee5eb);
        border-left: 4px solid #17a2b8;
        animation: complete-glow 3s ease-in-out;
    }
    
    .message.safety-warning {
        background: linear-gradient(135deg, #f8d7da, #f5c6cb);
        border-left: 4px solid #dc3545;
        animation: safety-warning-pulse 2s infinite;
        color: #721c24;
        font-weight: 500;
    }
    
    @@keyframes thinking-pulse {
        0%, 100% { opacity: 1; }
        50% { opacity: 0.8; }
    }
    
    @@keyframes analyzing-pulse {
        0%, 100% { transform: scale(1); }
        50% { transform: scale(1.02); }
    }
    
    @@keyframes todo-pulse {
        0%, 100% { box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2); }
        50% { box-shadow: 0 4px 8px rgba(220, 53, 69, 0.4); }
    }
    
    @@keyframes complete-glow {
        0%, 100% { box-shadow: 0 0 0 rgba(23, 162, 184, 0); }
        50% { box-shadow: 0 0 20px rgba(23, 162, 184, 0.5); }
    }
    
    @@keyframes safety-warning-pulse {
        0%, 100% { 
            box-shadow: 0 2px 4px rgba(220, 53, 69, 0.2);
            transform: scale(1);
        }
        50% { 
            box-shadow: 0 4px 8px rgba(220, 53, 69, 0.4);
            transform: scale(1.02);
        }
    }
</style>

<script>
    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const streamButton = document.getElementById('streamButton');
    const thinkButton = document.getElementById('thinkButton');
    const chatContainer = document.getElementById('chatContainer');

    let currentStreamingMessage = null;
    let typewriterTimeout = null;

    function addMessage(message, isUser = false, isStreaming = false, messageType = 'normal') {
        const messageDiv = document.createElement('div');
        messageDiv.className = `message ${isUser ? 'user-message' : 'bot-message'} ${isStreaming ? 'streaming' : ''} ${messageType}`;
        
        const sender = isUser ? 'You' : 'AI';
        const timestamp = new Date().toLocaleTimeString();
        
        if (isStreaming) {
            messageDiv.innerHTML = `
                <div class="message-header">
                    <strong>${sender}</strong>
                    <small class="timestamp">${timestamp}</small>
                    <span class="typing-indicator">‚óè</span>
                </div>
                <div class="message-content">${message}</div>
            `;
            currentStreamingMessage = messageDiv;
        } else {
            messageDiv.innerHTML = `
                <div class="message-header">
                    <strong>${sender}</strong>
                    <small class="timestamp">${timestamp}</small>
                </div>
                <div class="message-content">${message}</div>
            `;
        }
        
        chatContainer.appendChild(messageDiv);
        chatContainer.scrollTop = chatContainer.scrollHeight;
        
        return messageDiv;
    }

    function updateStreamingMessage(content) {
        if (currentStreamingMessage) {
            const contentDiv = currentStreamingMessage.querySelector('.message-content');
            if (contentDiv) {
                // Add typewriter effect with delay
                clearTimeout(typewriterTimeout);
                typewriterTimeout = setTimeout(() => {
                    contentDiv.textContent += content;
                    chatContainer.scrollTop = chatContainer.scrollHeight;
                }, 50); // 50ms delay for typewriter effect
            }
        }
    }

    function finalizeStreaming() {
        if (currentStreamingMessage) {
            currentStreamingMessage.classList.remove('streaming');
            const typingIndicator = currentStreamingMessage.querySelector('.typing-indicator');
            if (typingIndicator) {
                typingIndicator.style.display = 'none';
            }
            currentStreamingMessage = null;
        }
        clearTimeout(typewriterTimeout);
    }

    sendButton.addEventListener('click', async () => {
        const message = messageInput.value.trim();
        if (!message) return;

        addMessage(message, true);
        messageInput.value = '';
        sendButton.disabled = true;

        try {
            const response = await fetch('/api/ChatBot/chat', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ message: message })
            });

            if (response.ok) {
                const chatHistory = await response.json();
                // Display the last response from the chat history
                if (chatHistory.length > 0) {
                    const lastResponse = chatHistory[chatHistory.length - 1];
                    if (!lastResponse.isUserMessage) {
                        addMessage(lastResponse.message, false);
                    }
                }
            } else {
                addMessage('Error: Failed to get response', false);
            }
        } catch (error) {
            addMessage('Error: ' + error.message, false);
        } finally {
            sendButton.disabled = false;
        }
    });

    streamButton.addEventListener('click', async () => {
        const message = messageInput.value.trim();
        if (!message) return;

        addMessage(message, true);
        messageInput.value = '';
        streamButton.disabled = true;
        streamButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Streaming...';

        // Add streaming message placeholder with typing indicator
        addMessage('', false, true);

        try {
            const response = await fetch('/api/ChatBot/stream', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ message: message })
            });

            if (response.ok) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';
                let totalContent = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                finalizeStreaming();
                                break;
                            }
                            
                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.content) {
                                    totalContent += parsed.content;
                                    updateStreamingMessage(parsed.content);
                                    
                                    // Add a small delay to simulate real-time streaming
                                    await new Promise(resolve => setTimeout(resolve, 30));
                                }
                            } catch (e) {
                                // Ignore parsing errors for malformed JSON
                            }
                        }
                    }
                }
            } else {
                addMessage('Error: Failed to get streaming response', false);
            }
        } catch (error) {
            addMessage('Error: ' + error.message, false);
        } finally {
            streamButton.disabled = false;
            streamButton.innerHTML = 'Stream Response';
            finalizeStreaming();
        }
    });

    thinkButton.addEventListener('click', async () => {
        const message = messageInput.value.trim();
        if (!message) return;

        addMessage(message, true);
        messageInput.value = '';
        thinkButton.disabled = true;
        thinkButton.innerHTML = '<span class="spinner-border spinner-border-sm me-2"></span>Thinking...';

        try {
            const response = await fetch('/api/ChatBot/think', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({ message: message })
            });

            if (response.ok) {
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let buffer = '';

                while (true) {
                    const { done, value } = await reader.read();
                    if (done) break;

                    buffer += decoder.decode(value, { stream: true });
                    const lines = buffer.split('\n');
                    buffer = lines.pop() || '';

                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const data = line.slice(6);
                            if (data === '[DONE]') {
                                finalizeStreaming();
                                break;
                            }
                            
                            try {
                                const parsed = JSON.parse(data);
                                if (parsed.content) {
                                    if (parsed.type === 'thinking' || parsed.type === 'analyzing' || parsed.type === 'todo') {
                                        addMessage(parsed.content, false, false, parsed.type);
                                    } else if (parsed.type === 'safety_warning') {
                                        addMessage(parsed.content, false, false, 'safety-warning');
                                    } else if (parsed.type === 'response_start') {
                                        addMessage(parsed.content, false, true, 'response-start');
                                        currentStreamingMessage = chatContainer.lastElementChild;
                                    } else if (parsed.type === 'response') {
                                        updateStreamingMessage(parsed.content);
                                    } else if (parsed.type === 'complete') {
                                        finalizeStreaming();
                                        addMessage(parsed.content, false, false, 'complete');
                                    }
                                    
                                    // Add a small delay to simulate real-time streaming
                                    await new Promise(resolve => setTimeout(resolve, 200));
                                }
                            } catch (e) {
                                // Ignore parsing errors for malformed JSON
                            }
                        }
                    }
                }
            } else {
                addMessage('Error: Failed to get thinking response', false);
            }
        } catch (error) {
            addMessage('Error: ' + error.message, false);
        } finally {
            thinkButton.disabled = false;
            thinkButton.innerHTML = 'Think & Respond';
            finalizeStreaming();
        }
    });

    messageInput.addEventListener('keypress', (e) => {
        if (e.key === 'Enter') {
            sendButton.click();
        }
    });
</script>
